<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>花火アニメーション（BGM対応版）</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
  <style>
    body {
      padding: 0;
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script>
    // ==================================================================
    // --- パラメータ設定 ---
    // ==================================================================
    // 花火の生成と背景
    const NEW_FIREWORK_PROBABILITY = 0.01;
    const CLICK_FIREWORK_COUNT = 1;
    const BACKGROUND_FADE_ALPHA = 15;

    // 花火の種類ごとの数を設定（このオブジェクトの値を変更して確率を調整）
    const FIREWORK_TYPE_COUNTS = {
      normal: 16,
      colorChange: 4,
      bicolor: 4,
      splitColor: 4,
      speedColor: 4,
      kamuro: 4,
      heart: 2,
      smiley: 2
    };

    // 打ち上げ時の物理挙動
    const LAUNCH_SPEED_MIN = -11;
    const LAUNCH_SPEED_MAX = -6;
    const GRAVITY = 0.1;

    // 爆発時のパーティクル（粒子）設定
    const PARTICLE_COUNT_MIN = 80;
    const PARTICLE_COUNT_MAX = 200;
    const OUTER_RING_COUNT = 15;
    const COLOR_CHANGE_THRESHOLD = 135;
    const DEFAULT_PARTICLE_WEIGHT = 2;
    const KAMURO_TRAIL_WEIGHT = 1;
    const EXPLOSION_SPEED_MIN = 0.5;
    const EXPLOSION_SPEED_MAX = 10;
    const EXPLOSION_MAX_SPEED_MIN = 4;
    const PARTICLE_DRAG = 0.96;
    const PARTICLE_FADE_RATE = 3.5;

    // 特殊エフェクト関連
    const SPEED_COLOR_THRESHOLD = 5.0;
    const SPEED_COLOR_RING_COUNT = 15;
    const KAMURO_GRAVITY = 0.03;
    const KAMURO_FADE_RATE = 1.8;
    const HEART_PARTICLE_COUNT = 30;
    const HEART_EXPLOSION_SCALE = 0.2;
    const SMILEY_SCALE = 3;
    const SMILEY_OUTLINE_PARTICLE_COUNT = 20;
    const SMILEY_MOUTH_PARTICLE_COUNT = 4;
    const SMILEY_EYE_OFFSET_X = 0.4;
    const SMILEY_EYE_OFFSET_Y = 0.4;
    const SMILEY_EYE_SPEED = 1.5;

    // 音声関連
    const SOUND_DELAY_MS = 1000;
    const LAUNCH_SOUND_PROBABILITY = 0.2;
    const LAUNCH_SOUND_VOLUME = 0.1;
    const EXPLOSION_SOUND_VOLUME = 1.0;
    // ===== BGM追加 (1/4) =====
    const BGM_VOLUME = 0.04; // BGMの音量
    // ===========================

    // --- グローバル変数 ---
    const launchSounds = [];
    const NUM_LAUNCH_SOUNDS = 20;
    let nextLaunchSound = 0;

    const explosionSounds = [];
    const NUM_EXPLOSION_SOUNDS = 20;
    let nextExplosionSound = 0;

    let fireworks = [];
    let gravity;
    let kamuroGravity;
    // ===== BGM追加 (2/4) =====
    let bgm; // BGM用変数を追加
    // ===========================

    function preload() {
      try {
        soundFormats('mp3');
        // ===== BGM追加 (3/4) =====
        // BGMファイルを読み込む
        bgm = loadSound('Fireworks Blooming1.mp3');
        // ===========================

        for (let i = 0; i < NUM_LAUNCH_SOUNDS; i++) {
          launchSounds.push(loadSound('launch.mp3'));
        }
        const explosionSoundFiles = ['explosion1.mp3', 'explosion2.mp3', 'explosion3.mp3', 'explosion4.mp3', 'explosion5.mp3'];
        const numPerSound = NUM_EXPLOSION_SOUNDS / explosionSoundFiles.length;
        for (let i = 0; i < numPerSound; i++) {
          for (const file of explosionSoundFiles) {
            explosionSounds.push(loadSound(file));
          }
        }
      } catch (e) {
        // エラーメッセージにBGMファイル名を追加
        console.error("音声ファイルの読み込みに失敗しました。bgm.mp3, launch.mp3 と explosion1.mp3〜explosion5.mp3 を用意してください。");
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      gravity = createVector(0, GRAVITY);
      kamuroGravity = createVector(0, KAMURO_GRAVITY);
      stroke(255);
      colorMode(HSB);
      shuffle(explosionSounds, true);
    }

    function draw() {
      colorMode(RGB);
      background(0, 0, 0, BACKGROUND_FADE_ALPHA);
      if (random(1) < NEW_FIREWORK_PROBABILITY) {
        fireworks.push(new Firework());
      }
      for (let i = fireworks.length - 1; i >= 0; i--) {
        fireworks[i].update();
        fireworks[i].show();
        if (fireworks[i].done()) {
          fireworks.splice(i, 1);
        }
      }
    }

    function mousePressed() {
      if (getAudioContext().state !== 'running') {
        getAudioContext().resume();
      }
      
      // ===== BGM追加 (4/4) =====
      // ユーザーの最初のクリックでBGMのループ再生を開始
      // BGMがロード済みで、かつ再生中でない場合のみ実行
      if (bgm && bgm.isLoaded() && !bgm.isPlaying()) {
        bgm.setVolume(BGM_VOLUME);
        bgm.loop();
      }
      // ===========================

      for (let i = 0; i < CLICK_FIREWORK_COUNT; i++) {
        fireworks.push(new Firework(mouseX));
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }

    class Particle {
      constructor(x, y, isFirework, options = {}) {
        this.pos = createVector(x, y);
        this.isFirework = isFirework;
        this.lifespan = 255;
        this.acc = createVector(0, 0);
        this.history = [];
        this.hu = options.hu || 0;
        this.hu2 = options.hu2 || this.hu;
        this.type = options.type || 'point';
        this.effect = options.effect || 'normal';
        if (isFirework) {
          this.vel = createVector(0, random(LAUNCH_SPEED_MIN, LAUNCH_SPEED_MAX));
        } else {
          this.vel = options.velocity;
        }
      }
      applyForce(force) { this.acc.add(force); }
      update() {
        if (!this.isFirework) {
          this.vel.mult(PARTICLE_DRAG);
          this.lifespan -= (this.effect === 'kamuro') ? KAMURO_FADE_RATE : PARTICLE_FADE_RATE;
          if (this.type === 'line') {
            this.history.push(this.pos.copy());
            if (this.history.length > 30) this.history.splice(0, 1);
          }
        }
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.acc.mult(0);
      }
      done() { return this.lifespan < 0; }
      show() {
        colorMode(HSB);
        if (!this.isFirework) {
          strokeWeight((this.effect === 'kamuro') ? KAMURO_TRAIL_WEIGHT : DEFAULT_PARTICLE_WEIGHT);
          let currentHu = this.hu;
          if (this.effect === 'colorChange' && this.lifespan <= COLOR_CHANGE_THRESHOLD) {
            currentHu = this.hu2;
          }
          stroke(currentHu, 255, 255, this.lifespan);
          if (this.type === 'line') {
            beginShape();
            noFill();
            for (const p of this.history) vertex(p.x, p.y);
            endShape();
          } else {
            point(this.pos.x, this.pos.y);
          }
        } else {
          strokeWeight(4);
          stroke(this.hu, 255, 255);
          point(this.pos.x, this.pos.y);
        }
      }
    }

    class Firework {
      constructor(x) {
        this.launchSoundInstance = null;
        if (random(1) < LAUNCH_SOUND_PROBABILITY && launchSounds.length > 0) {
            this.launchSoundInstance = launchSounds[nextLaunchSound];
            const sound = this.launchSoundInstance;
            if (sound.isLoaded()) {
                setTimeout(() => {
                    sound.setVolume(LAUNCH_SOUND_VOLUME);
                    sound.play();
                }, SOUND_DELAY_MS);
            }
            nextLaunchSound = (nextLaunchSound + 1) % NUM_LAUNCH_SOUNDS;
        }

        const effects = [];
        for (const type in FIREWORK_TYPE_COUNTS) {
          const count = FIREWORK_TYPE_COUNTS[type];
          for (let i = 0; i < count; i++) {
            effects.push(type);
          }
        }
        this.effect = random(effects);

        if (this.effect === 'smiley' || this.effect === 'heart') {
          this.pitch = random(TWO_PI);
          this.yaw = random(TWO_PI);
        }

        if (this.effect === 'smiley') {
            this.huOutline = 60;
            this.huEyes = 120;
            this.huMouth = 0;
        } else if (this.effect === 'heart') {
            this.hu = 350;
        } else {
            this.hu = random(360);
        }

        this.type = (this.effect === 'kamuro') ? 'line' : 'point';

        if (this.effect === 'speedColor' || this.effect === 'bicolor' || this.effect === 'colorChange' || this.effect === 'splitColor') {
          this.hu2 = random(360);
        }
        
        if (this.effect === 'speedColor') {
          this.huSlow = random(360);
          this.huFast = random(360);
        }

        const startX = x || random(200, width - 200);
        this.firework = new Particle(startX, height, true, { hu: this.hu || this.huOutline });
        this.exploded = false;
        this.particles = [];
        this.particleCount = random(PARTICLE_COUNT_MIN, PARTICLE_COUNT_MAX);
      }

      done() { return this.exploded && this.particles.length === 0; }

      update() {
        if (!this.exploded) {
          this.firework.applyForce(gravity);
          this.firework.update();
          if (this.firework.vel.y >= 0) {
            this.exploded = true;
            this.explode();
          }
        } else {
          for (let i = this.particles.length - 1; i >= 0; i--) {
            if (this.particles[i].effect === 'kamuro' && !this.particles[i].isFirework) {
              this.particles[i].applyForce(kamuroGravity);
            }
            this.particles[i].update();
            if (this.particles[i].done()) {
              this.particles.splice(i, 1);
            }
          }
        }
      }
      
      _apply3DRotation(vector) {
        let rotatedX = vector.x * cos(this.yaw) + vector.z * sin(this.yaw);
        let rotatedZ_afterYaw = -vector.x * sin(this.yaw) + vector.z * cos(this.yaw);
        
        let rotatedY = vector.y * cos(this.pitch) - rotatedZ_afterYaw * sin(this.pitch);
        let rotatedZ_afterPitch = vector.y * sin(this.pitch) + rotatedZ_afterYaw * cos(this.pitch);

        return createVector(rotatedX, rotatedY, rotatedZ_afterPitch);
      }

      explode() {
        if (this.launchSoundInstance) {
          const soundToStop = this.launchSoundInstance;
          setTimeout(() => {
            if (soundToStop.isPlaying()) {
              soundToStop.stop();
            }
          }, SOUND_DELAY_MS);
        }

        if (explosionSounds.length > 0 && explosionSounds[nextExplosionSound].isLoaded()) {
          const sound = explosionSounds[nextExplosionSound];
          nextExplosionSound = (nextExplosionSound + 1) % NUM_EXPLOSION_SOUNDS;
          setTimeout(() => {
            sound.setVolume(EXPLOSION_SOUND_VOLUME);
            sound.play();
          }, SOUND_DELAY_MS);
        }

        if (this.effect === 'smiley') {
            const explosionCenter = this.firework.pos;
            const angleIncrement = TWO_PI / SMILEY_OUTLINE_PARTICLE_COUNT;
            for (let i = 0; i < SMILEY_OUTLINE_PARTICLE_COUNT; i++) {
                const angle = i * angleIncrement;
                let rotatedVec = this._apply3DRotation(createVector(cos(angle), sin(angle), 0));
                const vel = createVector(rotatedVec.x, rotatedVec.y).mult(SMILEY_SCALE);
                const options = { velocity: vel, effect: 'smiley', hu: this.huOutline };
                this.particles.push(new Particle(explosionCenter.x, explosionCenter.y, false, options));
            }
            let rotatedLeftEye = this._apply3DRotation(createVector(-SMILEY_EYE_OFFSET_X, -SMILEY_EYE_OFFSET_Y, 0));
            const velLeftEye = createVector(rotatedLeftEye.x, rotatedLeftEye.y).normalize().mult(SMILEY_EYE_SPEED);
            const leftEyeOptions = { velocity: velLeftEye, effect: 'smiley', hu: this.huEyes };
            this.particles.push(new Particle(explosionCenter.x, explosionCenter.y, false, leftEyeOptions));

            let rotatedRightEye = this._apply3DRotation(createVector(SMILEY_EYE_OFFSET_X, -SMILEY_EYE_OFFSET_Y, 0));
            const velRightEye = createVector(rotatedRightEye.x, rotatedRightEye.y).normalize().mult(SMILEY_EYE_SPEED);
            const rightEyeOptions = { velocity: velRightEye, effect: 'smiley', hu: this.huEyes };
            this.particles.push(new Particle(explosionCenter.x, explosionCenter.y, false, rightEyeOptions));
            
            if (SMILEY_MOUTH_PARTICLE_COUNT > 1) {
              for (let i = 0; i < SMILEY_MOUTH_PARTICLE_COUNT; i++) {
                const angle = map(i, 0, SMILEY_MOUTH_PARTICLE_COUNT - 1, PI * 0.2, PI * 0.8);
                let rotatedVec = this._apply3DRotation(createVector(cos(angle), sin(angle), 0));
                const vel = createVector(rotatedVec.x, rotatedVec.y).mult(SMILEY_SCALE * 0.6);
                const options = { velocity: vel, effect: 'smiley', hu: this.huMouth };
                this.particles.push(new Particle(explosionCenter.x, explosionCenter.y, false, options));
              }
            }
        } else if (this.effect === 'heart') {
            const particleCount = HEART_PARTICLE_COUNT;
            for (let i = 0; i < particleCount; i++) {
                const t = map(i, 0, particleCount, 0, TWO_PI);
                const x = 16 * pow(sin(t), 3);
                const y = -(13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t));
                
                let pos3d = this._apply3DRotation(createVector(x, y, 0));
                const vel = createVector(pos3d.x, pos3d.y).mult(HEART_EXPLOSION_SCALE);
                const particleOptions = { velocity: vel, type: this.type, effect: this.effect, hu: this.hu };
                this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
            }
        } else if (this.effect === 'kamuro') {
            const maxSpeed = EXPLOSION_SPEED_MAX / 2;
            for (let i = 0; i < this.particleCount; i++) {
                const vel = p5.Vector.random2D();
                let speed = random(EXPLOSION_SPEED_MIN, maxSpeed);
                vel.mult(speed);
                let particleOptions = { velocity: vel, type: this.type, effect: this.effect, hu: this.hu };
                this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
            }
            const angleIncrementOuter = TWO_PI / OUTER_RING_COUNT;
            for (let i = 0; i < OUTER_RING_COUNT; i++) {
                const angle = i * angleIncrementOuter;
                const velocity = p5.Vector.fromAngle(angle).mult(maxSpeed);
                let particleOptions = { velocity: velocity, type: this.type, effect: this.effect, hu: this.hu };
                this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
            }
        } else if (this.effect === 'splitColor') {
            const lineNormal = p5.Vector.fromAngle(random(TWO_PI));
            const currentMaxSpeed = random(EXPLOSION_MAX_SPEED_MIN, EXPLOSION_SPEED_MAX);
            for (let i = 0; i < this.particleCount; i++) {
                const vel = p5.Vector.random2D();
                const speed = random(EXPLOSION_SPEED_MIN, currentMaxSpeed);
                vel.mult(speed);
                const dotProduct = vel.dot(lineNormal);
                const currentHu = (dotProduct > 0) ? this.hu : this.hu2;
                let particleOptions = { velocity: vel, type: this.type, effect: this.effect, hu: currentHu };
                this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
            }
            const angleIncrementOuter = TWO_PI / OUTER_RING_COUNT;
            for (let i = 0; i < OUTER_RING_COUNT; i++) {
                const angle = i * angleIncrementOuter;
                const velocity = p5.Vector.fromAngle(angle).mult(currentMaxSpeed);
                const dotProduct = velocity.dot(lineNormal);
                const currentHu = (dotProduct > 0) ? this.hu : this.hu2;
                let particleOptions = { velocity: velocity, type: this.type, effect: this.effect, hu: currentHu };
                this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
            }
        } else {
            const currentMaxSpeed = random(EXPLOSION_MAX_SPEED_MIN, EXPLOSION_SPEED_MAX);
            let maxSlowSpeed = 0;
            for (let i = 0; i < this.particleCount; i++) {
                const vel = p5.Vector.random2D();
                let speed = random(EXPLOSION_SPEED_MIN, currentMaxSpeed);
                if (this.effect === 'speedColor' && speed <= SPEED_COLOR_THRESHOLD && speed > maxSlowSpeed) {
                    maxSlowSpeed = speed;
                }
                vel.mult(speed);
                let particleOptions = { velocity: vel, type: this.type, effect: this.effect };
                if (this.effect === 'bicolor') {
                    particleOptions.hu = random(1) < 0.5 ? this.hu : this.hu2;
                } else if (this.effect === 'speedColor') {
                    particleOptions.hu = speed > SPEED_COLOR_THRESHOLD ? this.huFast : this.huSlow;
                } else {
                    particleOptions.hu = this.hu;
                    particleOptions.hu2 = this.hu2;
                }
                this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
            }
            const angleIncrementOuter = TWO_PI / OUTER_RING_COUNT;
            for (let i = 0; i < OUTER_RING_COUNT; i++) {
                const angle = i * angleIncrementOuter;
                const velocity = p5.Vector.fromAngle(angle).mult(currentMaxSpeed);
                let particleOptions = { velocity: velocity, type: this.type, effect: this.effect };
                if (this.effect === 'bicolor') {
                    particleOptions.hu = random(1) < 0.5 ? this.hu : this.hu2;
                } else if (this.effect === 'speedColor') {
                    particleOptions.hu = this.huFast;
                } else {
                    particleOptions.hu = this.hu;
                    particleOptions.hu2 = this.hu2;
                }
                this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
            }
            if (this.effect === 'speedColor') {
                if (maxSlowSpeed > 0) {
                    const angleIncrementInner = TWO_PI / SPEED_COLOR_RING_COUNT;
                    for (let i = 0; i < SPEED_COLOR_RING_COUNT; i++) {
                        const angle = i * angleIncrementInner;
                        const velocity = p5.Vector.fromAngle(angle).mult(maxSlowSpeed);
                        let particleOptions = { velocity: velocity, type: this.type, effect: this.effect, hu: this.huSlow };
                        this.particles.push(new Particle(this.firework.pos.x, this.firework.pos.y, false, particleOptions));
                    }
                }
            }
        }
      }
      show() {
        if (!this.exploded) {
          this.firework.show();
        } else {
          for (let p of this.particles) p.show();
        }
      }
    }
  </script>
</body>
</html>